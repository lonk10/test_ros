// Code generated by rclgo-gen. DO NOT EDIT.

package mavros_msgs_msg
import (
	"unsafe"

	"github.com/tiiuae/rclgo/pkg/rclgo"
	"github.com/tiiuae/rclgo/pkg/rclgo/types"
	"github.com/tiiuae/rclgo/pkg/rclgo/typemap"
	std_msgs_msg "test/msgs/std_msgs/msg"
	
)
/*
#include <rosidl_runtime_c/message_type_support_struct.h>

#include <mavros_msgs/msg/hil_controls.h>

*/
import "C"

func init() {
	typemap.RegisterMessage("mavros_msgs/HilControls", HilControlsTypeSupport)
	typemap.RegisterMessage("mavros_msgs/msg/HilControls", HilControlsTypeSupport)
}

type HilControls struct {
	Header std_msgs_msg.Header `yaml:"header"`
	RollAilerons float32 `yaml:"roll_ailerons"`
	PitchElevator float32 `yaml:"pitch_elevator"`
	YawRudder float32 `yaml:"yaw_rudder"`
	Throttle float32 `yaml:"throttle"`
	Aux1 float32 `yaml:"aux1"`
	Aux2 float32 `yaml:"aux2"`
	Aux3 float32 `yaml:"aux3"`
	Aux4 float32 `yaml:"aux4"`
	Mode uint8 `yaml:"mode"`
	NavMode uint8 `yaml:"nav_mode"`
}

// NewHilControls creates a new HilControls with default values.
func NewHilControls() *HilControls {
	self := HilControls{}
	self.SetDefaults()
	return &self
}

func (t *HilControls) Clone() *HilControls {
	c := &HilControls{}
	c.Header = *t.Header.Clone()
	c.RollAilerons = t.RollAilerons
	c.PitchElevator = t.PitchElevator
	c.YawRudder = t.YawRudder
	c.Throttle = t.Throttle
	c.Aux1 = t.Aux1
	c.Aux2 = t.Aux2
	c.Aux3 = t.Aux3
	c.Aux4 = t.Aux4
	c.Mode = t.Mode
	c.NavMode = t.NavMode
	return c
}

func (t *HilControls) CloneMsg() types.Message {
	return t.Clone()
}

func (t *HilControls) SetDefaults() {
	t.Header.SetDefaults()
	t.RollAilerons = 0
	t.PitchElevator = 0
	t.YawRudder = 0
	t.Throttle = 0
	t.Aux1 = 0
	t.Aux2 = 0
	t.Aux3 = 0
	t.Aux4 = 0
	t.Mode = 0
	t.NavMode = 0
}

func (t *HilControls) GetTypeSupport() types.MessageTypeSupport {
	return HilControlsTypeSupport
}

// HilControlsPublisher wraps rclgo.Publisher to provide type safe helper
// functions
type HilControlsPublisher struct {
	*rclgo.Publisher
}

// NewHilControlsPublisher creates and returns a new publisher for the
// HilControls
func NewHilControlsPublisher(node *rclgo.Node, topic_name string, options *rclgo.PublisherOptions) (*HilControlsPublisher, error) {
	pub, err := node.NewPublisher(topic_name, HilControlsTypeSupport, options)
	if err != nil {
		return nil, err
	}
	return &HilControlsPublisher{pub}, nil
}

func (p *HilControlsPublisher) Publish(msg *HilControls) error {
	return p.Publisher.Publish(msg)
}

// HilControlsSubscription wraps rclgo.Subscription to provide type safe helper
// functions
type HilControlsSubscription struct {
	*rclgo.Subscription
}

// HilControlsSubscriptionCallback type is used to provide a subscription
// handler function for a HilControlsSubscription.
type HilControlsSubscriptionCallback func(msg *HilControls, info *rclgo.MessageInfo, err error)

// NewHilControlsSubscription creates and returns a new subscription for the
// HilControls
func NewHilControlsSubscription(node *rclgo.Node, topic_name string, opts *rclgo.SubscriptionOptions, subscriptionCallback HilControlsSubscriptionCallback) (*HilControlsSubscription, error) {
	callback := func(s *rclgo.Subscription) {
		var msg HilControls
		info, err := s.TakeMessage(&msg)
		subscriptionCallback(&msg, info, err)
	}
	sub, err := node.NewSubscription(topic_name, HilControlsTypeSupport, opts, callback)
	if err != nil {
		return nil, err
	}
	return &HilControlsSubscription{sub}, nil
}

func (s *HilControlsSubscription) TakeMessage(out *HilControls) (*rclgo.MessageInfo, error) {
	return s.Subscription.TakeMessage(out)
}

// CloneHilControlsSlice clones src to dst by calling Clone for each element in
// src. Panics if len(dst) < len(src).
func CloneHilControlsSlice(dst, src []HilControls) {
	for i := range src {
		dst[i] = *src[i].Clone()
	}
}

// Modifying this variable is undefined behavior.
var HilControlsTypeSupport types.MessageTypeSupport = _HilControlsTypeSupport{}

type _HilControlsTypeSupport struct{}

func (t _HilControlsTypeSupport) New() types.Message {
	return NewHilControls()
}

func (t _HilControlsTypeSupport) PrepareMemory() unsafe.Pointer { //returns *C.mavros_msgs__msg__HilControls
	return (unsafe.Pointer)(C.mavros_msgs__msg__HilControls__create())
}

func (t _HilControlsTypeSupport) ReleaseMemory(pointer_to_free unsafe.Pointer) {
	C.mavros_msgs__msg__HilControls__destroy((*C.mavros_msgs__msg__HilControls)(pointer_to_free))
}

func (t _HilControlsTypeSupport) AsCStruct(dst unsafe.Pointer, msg types.Message) {
	m := msg.(*HilControls)
	mem := (*C.mavros_msgs__msg__HilControls)(dst)
	std_msgs_msg.HeaderTypeSupport.AsCStruct(unsafe.Pointer(&mem.header), &m.Header)
	mem.roll_ailerons = C.float(m.RollAilerons)
	mem.pitch_elevator = C.float(m.PitchElevator)
	mem.yaw_rudder = C.float(m.YawRudder)
	mem.throttle = C.float(m.Throttle)
	mem.aux1 = C.float(m.Aux1)
	mem.aux2 = C.float(m.Aux2)
	mem.aux3 = C.float(m.Aux3)
	mem.aux4 = C.float(m.Aux4)
	mem.mode = C.uint8_t(m.Mode)
	mem.nav_mode = C.uint8_t(m.NavMode)
}

func (t _HilControlsTypeSupport) AsGoStruct(msg types.Message, ros2_message_buffer unsafe.Pointer) {
	m := msg.(*HilControls)
	mem := (*C.mavros_msgs__msg__HilControls)(ros2_message_buffer)
	std_msgs_msg.HeaderTypeSupport.AsGoStruct(&m.Header, unsafe.Pointer(&mem.header))
	m.RollAilerons = float32(mem.roll_ailerons)
	m.PitchElevator = float32(mem.pitch_elevator)
	m.YawRudder = float32(mem.yaw_rudder)
	m.Throttle = float32(mem.throttle)
	m.Aux1 = float32(mem.aux1)
	m.Aux2 = float32(mem.aux2)
	m.Aux3 = float32(mem.aux3)
	m.Aux4 = float32(mem.aux4)
	m.Mode = uint8(mem.mode)
	m.NavMode = uint8(mem.nav_mode)
}

func (t _HilControlsTypeSupport) TypeSupport() unsafe.Pointer {
	return unsafe.Pointer(C.rosidl_typesupport_c__get_message_type_support_handle__mavros_msgs__msg__HilControls())
}

type CHilControls = C.mavros_msgs__msg__HilControls
type CHilControls__Sequence = C.mavros_msgs__msg__HilControls__Sequence

func HilControls__Sequence_to_Go(goSlice *[]HilControls, cSlice CHilControls__Sequence) {
	if cSlice.size == 0 {
		return
	}
	*goSlice = make([]HilControls, cSlice.size)
	src := unsafe.Slice(cSlice.data, cSlice.size)
	for i := range src {
		HilControlsTypeSupport.AsGoStruct(&(*goSlice)[i], unsafe.Pointer(&src[i]))
	}
}
func HilControls__Sequence_to_C(cSlice *CHilControls__Sequence, goSlice []HilControls) {
	if len(goSlice) == 0 {
		cSlice.data = nil
		cSlice.capacity = 0
		cSlice.size = 0
		return
	}
	cSlice.data = (*C.mavros_msgs__msg__HilControls)(C.malloc(C.sizeof_struct_mavros_msgs__msg__HilControls * C.size_t(len(goSlice))))
	cSlice.capacity = C.size_t(len(goSlice))
	cSlice.size = cSlice.capacity
	dst := unsafe.Slice(cSlice.data, cSlice.size)
	for i := range goSlice {
		HilControlsTypeSupport.AsCStruct(unsafe.Pointer(&dst[i]), &goSlice[i])
	}
}
func HilControls__Array_to_Go(goSlice []HilControls, cSlice []CHilControls) {
	for i := 0; i < len(cSlice); i++ {
		HilControlsTypeSupport.AsGoStruct(&goSlice[i], unsafe.Pointer(&cSlice[i]))
	}
}
func HilControls__Array_to_C(cSlice []CHilControls, goSlice []HilControls) {
	for i := 0; i < len(goSlice); i++ {
		HilControlsTypeSupport.AsCStruct(unsafe.Pointer(&cSlice[i]), &goSlice[i])
	}
}
