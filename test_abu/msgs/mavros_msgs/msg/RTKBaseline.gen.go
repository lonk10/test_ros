// Code generated by rclgo-gen. DO NOT EDIT.

package mavros_msgs_msg
import (
	"unsafe"

	"github.com/tiiuae/rclgo/pkg/rclgo"
	"github.com/tiiuae/rclgo/pkg/rclgo/types"
	"github.com/tiiuae/rclgo/pkg/rclgo/typemap"
	std_msgs_msg "test/msgs/std_msgs/msg"
	
)
/*
#include <rosidl_runtime_c/message_type_support_struct.h>

#include <mavros_msgs/msg/rtk_baseline.h>

*/
import "C"

func init() {
	typemap.RegisterMessage("mavros_msgs/RTKBaseline", RTKBaselineTypeSupport)
	typemap.RegisterMessage("mavros_msgs/msg/RTKBaseline", RTKBaselineTypeSupport)
}
const (
	RTKBaseline_RTK_BASELINE_COORDINATE_SYSTEM_ECEF uint8 = 0// Earth-centered, earth-fixed
	RTKBaseline_RTK_BASELINE_COORDINATE_SYSTEM_NED uint8 = 1// RTK basestation centered, north, east, down
)

type RTKBaseline struct {
	Header std_msgs_msg.Header `yaml:"header"`
	TimeLastBaselineMs uint32 `yaml:"time_last_baseline_ms"`
	RtkReceiverId uint8 `yaml:"rtk_receiver_id"`
	Wn uint16 `yaml:"wn"`
	Tow uint32 `yaml:"tow"`
	RtkHealth uint8 `yaml:"rtk_health"`
	RtkRate uint8 `yaml:"rtk_rate"`
	Nsats uint8 `yaml:"nsats"`
	BaselineCoordsType uint8 `yaml:"baseline_coords_type"`
	BaselineAMm int32 `yaml:"baseline_a_mm"`
	BaselineBMm int32 `yaml:"baseline_b_mm"`
	BaselineCMm int32 `yaml:"baseline_c_mm"`
	Accuracy uint32 `yaml:"accuracy"`
	IarNumHypotheses int32 `yaml:"iar_num_hypotheses"`
}

// NewRTKBaseline creates a new RTKBaseline with default values.
func NewRTKBaseline() *RTKBaseline {
	self := RTKBaseline{}
	self.SetDefaults()
	return &self
}

func (t *RTKBaseline) Clone() *RTKBaseline {
	c := &RTKBaseline{}
	c.Header = *t.Header.Clone()
	c.TimeLastBaselineMs = t.TimeLastBaselineMs
	c.RtkReceiverId = t.RtkReceiverId
	c.Wn = t.Wn
	c.Tow = t.Tow
	c.RtkHealth = t.RtkHealth
	c.RtkRate = t.RtkRate
	c.Nsats = t.Nsats
	c.BaselineCoordsType = t.BaselineCoordsType
	c.BaselineAMm = t.BaselineAMm
	c.BaselineBMm = t.BaselineBMm
	c.BaselineCMm = t.BaselineCMm
	c.Accuracy = t.Accuracy
	c.IarNumHypotheses = t.IarNumHypotheses
	return c
}

func (t *RTKBaseline) CloneMsg() types.Message {
	return t.Clone()
}

func (t *RTKBaseline) SetDefaults() {
	t.Header.SetDefaults()
	t.TimeLastBaselineMs = 0
	t.RtkReceiverId = 0
	t.Wn = 0
	t.Tow = 0
	t.RtkHealth = 0
	t.RtkRate = 0
	t.Nsats = 0
	t.BaselineCoordsType = 0
	t.BaselineAMm = 0
	t.BaselineBMm = 0
	t.BaselineCMm = 0
	t.Accuracy = 0
	t.IarNumHypotheses = 0
}

func (t *RTKBaseline) GetTypeSupport() types.MessageTypeSupport {
	return RTKBaselineTypeSupport
}

// RTKBaselinePublisher wraps rclgo.Publisher to provide type safe helper
// functions
type RTKBaselinePublisher struct {
	*rclgo.Publisher
}

// NewRTKBaselinePublisher creates and returns a new publisher for the
// RTKBaseline
func NewRTKBaselinePublisher(node *rclgo.Node, topic_name string, options *rclgo.PublisherOptions) (*RTKBaselinePublisher, error) {
	pub, err := node.NewPublisher(topic_name, RTKBaselineTypeSupport, options)
	if err != nil {
		return nil, err
	}
	return &RTKBaselinePublisher{pub}, nil
}

func (p *RTKBaselinePublisher) Publish(msg *RTKBaseline) error {
	return p.Publisher.Publish(msg)
}

// RTKBaselineSubscription wraps rclgo.Subscription to provide type safe helper
// functions
type RTKBaselineSubscription struct {
	*rclgo.Subscription
}

// RTKBaselineSubscriptionCallback type is used to provide a subscription
// handler function for a RTKBaselineSubscription.
type RTKBaselineSubscriptionCallback func(msg *RTKBaseline, info *rclgo.MessageInfo, err error)

// NewRTKBaselineSubscription creates and returns a new subscription for the
// RTKBaseline
func NewRTKBaselineSubscription(node *rclgo.Node, topic_name string, opts *rclgo.SubscriptionOptions, subscriptionCallback RTKBaselineSubscriptionCallback) (*RTKBaselineSubscription, error) {
	callback := func(s *rclgo.Subscription) {
		var msg RTKBaseline
		info, err := s.TakeMessage(&msg)
		subscriptionCallback(&msg, info, err)
	}
	sub, err := node.NewSubscription(topic_name, RTKBaselineTypeSupport, opts, callback)
	if err != nil {
		return nil, err
	}
	return &RTKBaselineSubscription{sub}, nil
}

func (s *RTKBaselineSubscription) TakeMessage(out *RTKBaseline) (*rclgo.MessageInfo, error) {
	return s.Subscription.TakeMessage(out)
}

// CloneRTKBaselineSlice clones src to dst by calling Clone for each element in
// src. Panics if len(dst) < len(src).
func CloneRTKBaselineSlice(dst, src []RTKBaseline) {
	for i := range src {
		dst[i] = *src[i].Clone()
	}
}

// Modifying this variable is undefined behavior.
var RTKBaselineTypeSupport types.MessageTypeSupport = _RTKBaselineTypeSupport{}

type _RTKBaselineTypeSupport struct{}

func (t _RTKBaselineTypeSupport) New() types.Message {
	return NewRTKBaseline()
}

func (t _RTKBaselineTypeSupport) PrepareMemory() unsafe.Pointer { //returns *C.mavros_msgs__msg__RTKBaseline
	return (unsafe.Pointer)(C.mavros_msgs__msg__RTKBaseline__create())
}

func (t _RTKBaselineTypeSupport) ReleaseMemory(pointer_to_free unsafe.Pointer) {
	C.mavros_msgs__msg__RTKBaseline__destroy((*C.mavros_msgs__msg__RTKBaseline)(pointer_to_free))
}

func (t _RTKBaselineTypeSupport) AsCStruct(dst unsafe.Pointer, msg types.Message) {
	m := msg.(*RTKBaseline)
	mem := (*C.mavros_msgs__msg__RTKBaseline)(dst)
	std_msgs_msg.HeaderTypeSupport.AsCStruct(unsafe.Pointer(&mem.header), &m.Header)
	mem.time_last_baseline_ms = C.uint32_t(m.TimeLastBaselineMs)
	mem.rtk_receiver_id = C.uint8_t(m.RtkReceiverId)
	mem.wn = C.uint16_t(m.Wn)
	mem.tow = C.uint32_t(m.Tow)
	mem.rtk_health = C.uint8_t(m.RtkHealth)
	mem.rtk_rate = C.uint8_t(m.RtkRate)
	mem.nsats = C.uint8_t(m.Nsats)
	mem.baseline_coords_type = C.uint8_t(m.BaselineCoordsType)
	mem.baseline_a_mm = C.int32_t(m.BaselineAMm)
	mem.baseline_b_mm = C.int32_t(m.BaselineBMm)
	mem.baseline_c_mm = C.int32_t(m.BaselineCMm)
	mem.accuracy = C.uint32_t(m.Accuracy)
	mem.iar_num_hypotheses = C.int32_t(m.IarNumHypotheses)
}

func (t _RTKBaselineTypeSupport) AsGoStruct(msg types.Message, ros2_message_buffer unsafe.Pointer) {
	m := msg.(*RTKBaseline)
	mem := (*C.mavros_msgs__msg__RTKBaseline)(ros2_message_buffer)
	std_msgs_msg.HeaderTypeSupport.AsGoStruct(&m.Header, unsafe.Pointer(&mem.header))
	m.TimeLastBaselineMs = uint32(mem.time_last_baseline_ms)
	m.RtkReceiverId = uint8(mem.rtk_receiver_id)
	m.Wn = uint16(mem.wn)
	m.Tow = uint32(mem.tow)
	m.RtkHealth = uint8(mem.rtk_health)
	m.RtkRate = uint8(mem.rtk_rate)
	m.Nsats = uint8(mem.nsats)
	m.BaselineCoordsType = uint8(mem.baseline_coords_type)
	m.BaselineAMm = int32(mem.baseline_a_mm)
	m.BaselineBMm = int32(mem.baseline_b_mm)
	m.BaselineCMm = int32(mem.baseline_c_mm)
	m.Accuracy = uint32(mem.accuracy)
	m.IarNumHypotheses = int32(mem.iar_num_hypotheses)
}

func (t _RTKBaselineTypeSupport) TypeSupport() unsafe.Pointer {
	return unsafe.Pointer(C.rosidl_typesupport_c__get_message_type_support_handle__mavros_msgs__msg__RTKBaseline())
}

type CRTKBaseline = C.mavros_msgs__msg__RTKBaseline
type CRTKBaseline__Sequence = C.mavros_msgs__msg__RTKBaseline__Sequence

func RTKBaseline__Sequence_to_Go(goSlice *[]RTKBaseline, cSlice CRTKBaseline__Sequence) {
	if cSlice.size == 0 {
		return
	}
	*goSlice = make([]RTKBaseline, cSlice.size)
	src := unsafe.Slice(cSlice.data, cSlice.size)
	for i := range src {
		RTKBaselineTypeSupport.AsGoStruct(&(*goSlice)[i], unsafe.Pointer(&src[i]))
	}
}
func RTKBaseline__Sequence_to_C(cSlice *CRTKBaseline__Sequence, goSlice []RTKBaseline) {
	if len(goSlice) == 0 {
		cSlice.data = nil
		cSlice.capacity = 0
		cSlice.size = 0
		return
	}
	cSlice.data = (*C.mavros_msgs__msg__RTKBaseline)(C.malloc(C.sizeof_struct_mavros_msgs__msg__RTKBaseline * C.size_t(len(goSlice))))
	cSlice.capacity = C.size_t(len(goSlice))
	cSlice.size = cSlice.capacity
	dst := unsafe.Slice(cSlice.data, cSlice.size)
	for i := range goSlice {
		RTKBaselineTypeSupport.AsCStruct(unsafe.Pointer(&dst[i]), &goSlice[i])
	}
}
func RTKBaseline__Array_to_Go(goSlice []RTKBaseline, cSlice []CRTKBaseline) {
	for i := 0; i < len(cSlice); i++ {
		RTKBaselineTypeSupport.AsGoStruct(&goSlice[i], unsafe.Pointer(&cSlice[i]))
	}
}
func RTKBaseline__Array_to_C(cSlice []CRTKBaseline, goSlice []RTKBaseline) {
	for i := 0; i < len(goSlice); i++ {
		RTKBaselineTypeSupport.AsCStruct(unsafe.Pointer(&cSlice[i]), &goSlice[i])
	}
}
