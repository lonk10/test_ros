// Code generated by rclgo-gen. DO NOT EDIT.

package mavros_msgs_msg
import (
	"unsafe"

	"github.com/tiiuae/rclgo/pkg/rclgo"
	"github.com/tiiuae/rclgo/pkg/rclgo/types"
	"github.com/tiiuae/rclgo/pkg/rclgo/typemap"
	primitives "github.com/tiiuae/rclgo/pkg/rclgo/primitives"
	std_msgs_msg "test/msgs/std_msgs/msg"
	
)
/*
#include <rosidl_runtime_c/message_type_support_struct.h>

#include <mavros_msgs/msg/mavlink.h>

*/
import "C"

func init() {
	typemap.RegisterMessage("mavros_msgs/Mavlink", MavlinkTypeSupport)
	typemap.RegisterMessage("mavros_msgs/msg/Mavlink", MavlinkTypeSupport)
}
const (
	Mavlink_FRAMING_OK uint8 = 1// mavlink_framing_t enum
	Mavlink_FRAMING_BAD_CRC uint8 = 2
	Mavlink_FRAMING_BAD_SIGNATURE uint8 = 3
	Mavlink_MAVLINK_V10 uint8 = 254// stx values
	Mavlink_MAVLINK_V20 uint8 = 253
)

type Mavlink struct {
	Header std_msgs_msg.Header `yaml:"header"`
	FramingStatus uint8 `yaml:"framing_status"`
	Magic uint8 `yaml:"magic"`// STX byte
	Len uint8 `yaml:"len"`
	IncompatFlags uint8 `yaml:"incompat_flags"`
	CompatFlags uint8 `yaml:"compat_flags"`
	Seq uint8 `yaml:"seq"`
	Sysid uint8 `yaml:"sysid"`
	Compid uint8 `yaml:"compid"`
	Msgid uint32 `yaml:"msgid"`// 24-bit message id
	Checksum uint16 `yaml:"checksum"`
	Payload64 []uint64 `yaml:"payload64"`// max size: (255+2+7)/8
	Signature []uint8 `yaml:"signature"`// optional signature, max size: 13
}

// NewMavlink creates a new Mavlink with default values.
func NewMavlink() *Mavlink {
	self := Mavlink{}
	self.SetDefaults()
	return &self
}

func (t *Mavlink) Clone() *Mavlink {
	c := &Mavlink{}
	c.Header = *t.Header.Clone()
	c.FramingStatus = t.FramingStatus
	c.Magic = t.Magic
	c.Len = t.Len
	c.IncompatFlags = t.IncompatFlags
	c.CompatFlags = t.CompatFlags
	c.Seq = t.Seq
	c.Sysid = t.Sysid
	c.Compid = t.Compid
	c.Msgid = t.Msgid
	c.Checksum = t.Checksum
	if t.Payload64 != nil {
		c.Payload64 = make([]uint64, len(t.Payload64))
		copy(c.Payload64, t.Payload64)
	}
	if t.Signature != nil {
		c.Signature = make([]uint8, len(t.Signature))
		copy(c.Signature, t.Signature)
	}
	return c
}

func (t *Mavlink) CloneMsg() types.Message {
	return t.Clone()
}

func (t *Mavlink) SetDefaults() {
	t.Header.SetDefaults()
	t.FramingStatus = 0
	t.Magic = 0
	t.Len = 0
	t.IncompatFlags = 0
	t.CompatFlags = 0
	t.Seq = 0
	t.Sysid = 0
	t.Compid = 0
	t.Msgid = 0
	t.Checksum = 0
	t.Payload64 = nil
	t.Signature = nil
}

func (t *Mavlink) GetTypeSupport() types.MessageTypeSupport {
	return MavlinkTypeSupport
}

// MavlinkPublisher wraps rclgo.Publisher to provide type safe helper
// functions
type MavlinkPublisher struct {
	*rclgo.Publisher
}

// NewMavlinkPublisher creates and returns a new publisher for the
// Mavlink
func NewMavlinkPublisher(node *rclgo.Node, topic_name string, options *rclgo.PublisherOptions) (*MavlinkPublisher, error) {
	pub, err := node.NewPublisher(topic_name, MavlinkTypeSupport, options)
	if err != nil {
		return nil, err
	}
	return &MavlinkPublisher{pub}, nil
}

func (p *MavlinkPublisher) Publish(msg *Mavlink) error {
	return p.Publisher.Publish(msg)
}

// MavlinkSubscription wraps rclgo.Subscription to provide type safe helper
// functions
type MavlinkSubscription struct {
	*rclgo.Subscription
}

// MavlinkSubscriptionCallback type is used to provide a subscription
// handler function for a MavlinkSubscription.
type MavlinkSubscriptionCallback func(msg *Mavlink, info *rclgo.MessageInfo, err error)

// NewMavlinkSubscription creates and returns a new subscription for the
// Mavlink
func NewMavlinkSubscription(node *rclgo.Node, topic_name string, opts *rclgo.SubscriptionOptions, subscriptionCallback MavlinkSubscriptionCallback) (*MavlinkSubscription, error) {
	callback := func(s *rclgo.Subscription) {
		var msg Mavlink
		info, err := s.TakeMessage(&msg)
		subscriptionCallback(&msg, info, err)
	}
	sub, err := node.NewSubscription(topic_name, MavlinkTypeSupport, opts, callback)
	if err != nil {
		return nil, err
	}
	return &MavlinkSubscription{sub}, nil
}

func (s *MavlinkSubscription) TakeMessage(out *Mavlink) (*rclgo.MessageInfo, error) {
	return s.Subscription.TakeMessage(out)
}

// CloneMavlinkSlice clones src to dst by calling Clone for each element in
// src. Panics if len(dst) < len(src).
func CloneMavlinkSlice(dst, src []Mavlink) {
	for i := range src {
		dst[i] = *src[i].Clone()
	}
}

// Modifying this variable is undefined behavior.
var MavlinkTypeSupport types.MessageTypeSupport = _MavlinkTypeSupport{}

type _MavlinkTypeSupport struct{}

func (t _MavlinkTypeSupport) New() types.Message {
	return NewMavlink()
}

func (t _MavlinkTypeSupport) PrepareMemory() unsafe.Pointer { //returns *C.mavros_msgs__msg__Mavlink
	return (unsafe.Pointer)(C.mavros_msgs__msg__Mavlink__create())
}

func (t _MavlinkTypeSupport) ReleaseMemory(pointer_to_free unsafe.Pointer) {
	C.mavros_msgs__msg__Mavlink__destroy((*C.mavros_msgs__msg__Mavlink)(pointer_to_free))
}

func (t _MavlinkTypeSupport) AsCStruct(dst unsafe.Pointer, msg types.Message) {
	m := msg.(*Mavlink)
	mem := (*C.mavros_msgs__msg__Mavlink)(dst)
	std_msgs_msg.HeaderTypeSupport.AsCStruct(unsafe.Pointer(&mem.header), &m.Header)
	mem.framing_status = C.uint8_t(m.FramingStatus)
	mem.magic = C.uint8_t(m.Magic)
	mem.len = C.uint8_t(m.Len)
	mem.incompat_flags = C.uint8_t(m.IncompatFlags)
	mem.compat_flags = C.uint8_t(m.CompatFlags)
	mem.seq = C.uint8_t(m.Seq)
	mem.sysid = C.uint8_t(m.Sysid)
	mem.compid = C.uint8_t(m.Compid)
	mem.msgid = C.uint32_t(m.Msgid)
	mem.checksum = C.uint16_t(m.Checksum)
	primitives.Uint64__Sequence_to_C((*primitives.CUint64__Sequence)(unsafe.Pointer(&mem.payload64)), m.Payload64)
	primitives.Uint8__Sequence_to_C((*primitives.CUint8__Sequence)(unsafe.Pointer(&mem.signature)), m.Signature)
}

func (t _MavlinkTypeSupport) AsGoStruct(msg types.Message, ros2_message_buffer unsafe.Pointer) {
	m := msg.(*Mavlink)
	mem := (*C.mavros_msgs__msg__Mavlink)(ros2_message_buffer)
	std_msgs_msg.HeaderTypeSupport.AsGoStruct(&m.Header, unsafe.Pointer(&mem.header))
	m.FramingStatus = uint8(mem.framing_status)
	m.Magic = uint8(mem.magic)
	m.Len = uint8(mem.len)
	m.IncompatFlags = uint8(mem.incompat_flags)
	m.CompatFlags = uint8(mem.compat_flags)
	m.Seq = uint8(mem.seq)
	m.Sysid = uint8(mem.sysid)
	m.Compid = uint8(mem.compid)
	m.Msgid = uint32(mem.msgid)
	m.Checksum = uint16(mem.checksum)
	primitives.Uint64__Sequence_to_Go(&m.Payload64, *(*primitives.CUint64__Sequence)(unsafe.Pointer(&mem.payload64)))
	primitives.Uint8__Sequence_to_Go(&m.Signature, *(*primitives.CUint8__Sequence)(unsafe.Pointer(&mem.signature)))
}

func (t _MavlinkTypeSupport) TypeSupport() unsafe.Pointer {
	return unsafe.Pointer(C.rosidl_typesupport_c__get_message_type_support_handle__mavros_msgs__msg__Mavlink())
}

type CMavlink = C.mavros_msgs__msg__Mavlink
type CMavlink__Sequence = C.mavros_msgs__msg__Mavlink__Sequence

func Mavlink__Sequence_to_Go(goSlice *[]Mavlink, cSlice CMavlink__Sequence) {
	if cSlice.size == 0 {
		return
	}
	*goSlice = make([]Mavlink, cSlice.size)
	src := unsafe.Slice(cSlice.data, cSlice.size)
	for i := range src {
		MavlinkTypeSupport.AsGoStruct(&(*goSlice)[i], unsafe.Pointer(&src[i]))
	}
}
func Mavlink__Sequence_to_C(cSlice *CMavlink__Sequence, goSlice []Mavlink) {
	if len(goSlice) == 0 {
		cSlice.data = nil
		cSlice.capacity = 0
		cSlice.size = 0
		return
	}
	cSlice.data = (*C.mavros_msgs__msg__Mavlink)(C.malloc(C.sizeof_struct_mavros_msgs__msg__Mavlink * C.size_t(len(goSlice))))
	cSlice.capacity = C.size_t(len(goSlice))
	cSlice.size = cSlice.capacity
	dst := unsafe.Slice(cSlice.data, cSlice.size)
	for i := range goSlice {
		MavlinkTypeSupport.AsCStruct(unsafe.Pointer(&dst[i]), &goSlice[i])
	}
}
func Mavlink__Array_to_Go(goSlice []Mavlink, cSlice []CMavlink) {
	for i := 0; i < len(cSlice); i++ {
		MavlinkTypeSupport.AsGoStruct(&goSlice[i], unsafe.Pointer(&cSlice[i]))
	}
}
func Mavlink__Array_to_C(cSlice []CMavlink, goSlice []Mavlink) {
	for i := 0; i < len(goSlice); i++ {
		MavlinkTypeSupport.AsCStruct(unsafe.Pointer(&cSlice[i]), &goSlice[i])
	}
}
